--
-- This will eventually be the script that is run to set up the database initially for pgdoc
--

-- Create the database and connect to it
-- NOTE: This may be done in a separate script later
CREATE DATABASE pgdoc;
\c pgdoc

-- Create a user so the program can access the database without an admin account
CREATE ROLE pgdoc LOGIN;

CREATE SCHEMA pgdoc;
GRANT create,usage ON SCHEMA pgdoc TO pgdoc ;
-- TODO: write a script to do the above 2 lines for an arbitrary schema, an error message that explains the script AND gives these lines for the schema provided


-- Create the table that will store all user data
CREATE TABLE pgdoc.docs (
  type TEXT, -- Contains the type of document stored
  data JSONB -- Contains the document in JSON form
);
ALTER TABLE pgdoc.docs OWNER TO pgdoc;

-- Create role for game servers to register with
GRANT SELECT,INSERT,UPDATE ON TABLE pgdoc.docs TO pgdoc;

-- Create a named sequence when an ID is requested for the first time for a given document type.
CREATE OR REPLACE FUNCTION pgdoc.generateSequence( schemaName TEXT, type TEXT )
RETURNS TEXT AS
$$
DECLARE seqName TEXT;
BEGIN
  seqName := type || 'Sequence' ;
  EXECUTE 'CREATE SEQUENCE '
    || schemaName
    || '.'
    || seqName
    || ' AS integer '
    || 'START WITH 1 '
    || 'INCREMENT BY 1 '
    || 'MINVALUE 1 '
    || 'NO MAXVALUE '
    || 'CACHE 1;';
  EXECUTE 'GRANT SELECT,USAGE ON SEQUENCE ' || schemaName || '.' || seqName || ' TO pgdoc;';
  RETURN seqName;
END;
$$
LANGUAGE plpgsql;
ALTER FUNCTION pgdoc.generateSequence( TEXT, TEXT ) OWNER TO pgdoc;

-- Create a named sequence when an ID is requested for the first time for a given document type.
CREATE OR REPLACE FUNCTION pgdoc.incrementSequence( schemaName TEXT, type TEXT )
RETURNS TEXT AS
$$
DECLARE seqName TEXT;
DECLARE typeID  TEXT;
BEGIN
  seqName := schemaName || '.' || type || 'Sequence' ;
  IF
    (SELECT to_regclass(seqName))
  IS NULL
  THEN
    -- generate new sequence as needed
    PERFORM pgdoc.generateSequence(schemaName, type);
  END IF;
  typeID  := nextval( seqName )::TEXT ;
  RETURN typeID;
END;
$$
LANGUAGE plpgsql;

ALTER FUNCTION pgdoc.incrementSequence( TEXT, TEXT ) OWNER TO pgdoc;



-- Delete a set of documents returned by a search and replace with provided data if the record count to be deleted is under provided maximum
-- If the max is breached, instead return the number of records that would have been deleted as a negative number.
CREATE OR REPLACE FUNCTION pgdoc.overwriteUnderMax( schemaName TEXT, docType TEXT, newData JSONB, search JSONB, max INTEGER )
RETURNS INTEGER AS
$$
DECLARE recordCount INTEGER;
BEGIN
  recordCount := ( SELECT COUNT(*) FROM pgdoc.docs WHERE type = docType AND data @> search ) ;
  -- RAISE NOTICE 'recordCount: %', recordCount;
  IF
    recordCount <= max
  THEN
    -- delete, store and return
    DELETE FROM pgdoc.docs WHERE type = docType AND data @> search;
    INSERT INTO pgdoc.docs VALUES (docType, newData);
    RETURN recordCount;
  ELSE
    RETURN -recordCount;
  END IF;
END;
$$
LANGUAGE plpgsql;
ALTER FUNCTION pgdoc.overwriteUnderMax( TEXT, TEXT, JSONB, JSONB, INTEGER ) OWNER TO pgdoc;
-- DROP FUNCTION pgdoc.overwriteUnderMax( TEXT, TEXT, JSONB, JSONB, INTEGER );

-- SELECT pgdoc.overwriteUnderMax( 'pgdoc', 'player', '{ "name": "John Smith", "age": 44, "team": "red", "id": "-1" }', '{ "id": "-1" }', 1 ) ;
-- SELECT data FROM pgdoc.docs WHERE type = 'player' AND data @> '{"id":"-1"}';
-- INSERT INTO pgdoc.docs VALUES ('player', '{"name":"John Smith","age":42,"team":"red","id":"-1"}');


-- Delete a set of documents returned by a search and replace with provided data if the record count to be deleted is under provided maximum
-- Refine the search with a second exclude search
-- If the max is breached, instead return the number of records that would have been deleted as a negative number.
CREATE OR REPLACE FUNCTION pgdoc.overwriteUnderMaxExcluding( schemaName TEXT, docType TEXT, newData JSONB, search JSONB, max INTEGER, exclude JSONB )
RETURNS INTEGER AS
$$
DECLARE recordCount INTEGER;
BEGIN
  recordCount := ( SELECT COUNT(*) FROM pgdoc.docs WHERE type = docType AND data @> search AND NOT data @> exclude) ;
  -- RAISE NOTICE 'recordCount: %', recordCount;
  IF
    recordCount <= max
  THEN
    -- delete, store and return
    DELETE FROM pgdoc.docs WHERE type = docType AND data @> search AND NOT data @> exclude;
    INSERT INTO pgdoc.docs VALUES (docType, newData);
    RETURN recordCount;
  ELSE
    RETURN -recordCount;
  END IF;
END;
$$
LANGUAGE plpgsql;
ALTER FUNCTION pgdoc.overwriteUnderMaxExcluding( TEXT, TEXT, JSONB, JSONB, INTEGER, JSONB ) OWNER TO pgdoc;


-- Select a set of documents returned by a search if the record count is under provided maximum
-- If the max is breached, instead return the number of records that would have been selected as a negative number.
CREATE OR REPLACE FUNCTION pgdoc.retrieveUnderMax( schemaName TEXT, docType TEXT, search JSONB, max INTEGER )
RETURNS SETOF JSONB AS
$$
DECLARE recordCount INTEGER;
BEGIN
  recordCount := ( SELECT COUNT(*) FROM pgdoc.docs WHERE type = docType AND data @> search ) ;
  -- RAISE NOTICE 'recordCount: %', recordCount;
  IF
    recordCount <= max
  THEN
    RETURN QUERY SELECT data FROM pgdoc.docs WHERE type = docType AND data @> search ;
  ELSE
    RETURN QUERY SELECT ('{ "MaxExceededError": ' || -recordCount || ' }')::JSONB;
  END IF;
END;
$$
LANGUAGE plpgsql;
ALTER FUNCTION pgdoc.retrieveUnderMax( TEXT, TEXT, JSONB, INTEGER ) OWNER TO pgdoc;
-- SELECT pgdoc.retrieveUnderMax( 'pgdoc', 'pgdocTest', '{"complex":{"a":{"t":1,"u":-5},"b":3}}', 1 );
-- SELECT pgdoc.retrieveUnderMax( 'pgdoc', 'pgdocTest', '{"complex":{"a":{"t":1,"u":-5},"b":3}}', 0 );
-- SELECT data FROM pgdoc.docs WHERE type = 'pgdocTest' AND data @> '{"complex":{"a":{"t":1,"u":-5},"b":3}}' ;



CREATE OR REPLACE FUNCTION pgdoc.retrieveUnderMaxExcluding( schemaName TEXT, docType TEXT, search JSONB, max INTEGER, exclude JSONB )
RETURNS SETOF JSONB AS
$$
DECLARE recordCount INTEGER;
BEGIN
  recordCount := ( SELECT COUNT(*) FROM pgdoc.docs WHERE type = docType AND data @> search AND NOT data @> exclude ) ;
  -- RAISE NOTICE 'recordCount: %', recordCount;
  IF
    recordCount <= max
  THEN
    RETURN QUERY SELECT data FROM pgdoc.docs WHERE type = docType AND data @> search AND NOT data @> exclude ;
  ELSE
    RETURN QUERY SELECT ('{ "MaxExceededError": ' || -recordCount || ' }')::JSONB;
  END IF;
END;
$$
LANGUAGE plpgsql;
ALTER FUNCTION pgdoc.retrieveUnderMaxExcluding( TEXT, TEXT, JSONB, INTEGER, JSONB ) OWNER TO pgdoc;



-- Delete a set of documents returned by a search if the record count is under provided maximum
-- If the max is breached, instead return the number of records that would have been selected as a negative number.
CREATE OR REPLACE FUNCTION pgdoc.deleteUnderMax( schemaName TEXT, docType TEXT, search JSONB, max INTEGER )
RETURNS SETOF JSONB AS
$$
DECLARE recordCount INTEGER;
BEGIN
  recordCount := ( SELECT COUNT(*) FROM pgdoc.docs WHERE type = docType AND data @> search ) ;
  -- RAISE NOTICE 'recordCount: %', recordCount;
  IF
    recordCount <= max
  THEN
    DELETE FROM pgdoc.docs WHERE type = docType AND data @> search ;
    RETURN QUERY SELECT ('{ "deleted": ' || recordCount || ' }')::JSONB;
  ELSE
    RETURN QUERY SELECT ('{ "MaxExceededError": ' || -recordCount || ' }')::JSONB;
  END IF;
END;
$$
LANGUAGE plpgsql;
ALTER FUNCTION pgdoc.deleteUnderMax( TEXT, TEXT, JSONB, INTEGER ) OWNER TO pgdoc;


CREATE OR REPLACE FUNCTION pgdoc.deleteUnderMaxExcluding( schemaName TEXT, docType TEXT, search JSONB, max INTEGER, exclude JSONB )
RETURNS SETOF JSONB AS
$$
DECLARE recordCount INTEGER;
BEGIN
  recordCount := ( SELECT COUNT(*) FROM pgdoc.docs WHERE type = docType AND data @> search AND NOT data @> exclude ) ;
  -- RAISE NOTICE 'recordCount: %', recordCount;
  IF
    recordCount <= max
  THEN
    DELETE FROM pgdoc.docs WHERE type = docType AND data @> search AND NOT data @> exclude ;
    RETURN QUERY SELECT ('{ "deleted": ' || recordCount || ' }')::JSONB;
  ELSE
    RETURN QUERY SELECT ('{ "MaxExceededError": ' || -recordCount || ' }')::JSONB;
  END IF;
END;
$$
LANGUAGE plpgsql;
ALTER FUNCTION pgdoc.deleteUnderMaxExcluding( TEXT, TEXT, JSONB, INTEGER, JSONB ) OWNER TO pgdoc;








CREATE OR REPLACE FUNCTION  pgdoc.store( command INTEGER, schemaName TEXT, docType TEXT, doc JSONB, search JSONB, max INTEGER, exclude JSONB )
RETURNS SETOF JSONB AS
$$
DECLARE recordCount INTEGER;
DECLARE docs TEXT;
BEGIN
  docs := schemaName || '.docs' ;
  -- RAISE NOTICE 'recordCount: %', recordCount;
  IF command = 1 -- store()
  THEN
    INSERT INTO docs VALUES ( docType , doc );
    RETURN QUERY SELECT ('{ "deleted": 0 }')::JSONB;
  ELSIF command = 2 -- store(), search
  THEN
    recordCount := COUNT(*) FROM docs WHERE type = docType AND data @> search ;
    DELETE FROM docs WHERE type = docType AND data @> search ;
    INSERT INTO docs VALUES ( docType , doc );
    RETURN QUERY SELECT ('{ "deleted": ' || recordCount || ' }')::JSONB;
  ELSIF command = 3 -- store(), search with maxMatch
  THEN
    recordCount := COUNT(*) FROM docs WHERE type = docType AND data @> search ;
    IF recordCount <= max
    THEN
      DELETE FROM docs WHERE type = docType AND data @> search ;
      INSERT INTO docs VALUES ( docType , doc );
      RETURN QUERY SELECT ('{ "deleted": ' || recordCount || ' }')::JSONB;
    ELSE
      RETURN QUERY SELECT ('{ "MaxExceededError": ' || recordCount || ' }')::JSONB;
    END IF;
  ELSIF command = 4 -- store(), search & exclude
  THEN
    recordCount := COUNT(*) FROM docs WHERE type = docType AND data @> search AND NOT data @> exclude ;
    DELETE FROM docs WHERE type = docType AND data @> search AND NOT data @> exclude ;
    INSERT INTO docs VALUES ( docType , doc );
    RETURN QUERY SELECT ('{ "deleted": ' || recordCount || ' }')::JSONB;
  ELSIF command = 5 -- store(), search & exclude with maxMatch
  THEN
    recordCount := COUNT(*) FROM docs WHERE type = docType AND data @> search AND NOT data @> exclude;
    IF recordCount <= max
    THEN
      DELETE FROM docs WHERE type = docType AND data @> search AND NOT data @> exclude;
      INSERT INTO docs VALUES ( docType , doc );
      RETURN QUERY SELECT ('{ "deleted": ' || recordCount || ' }')::JSONB;
    ELSE
      RETURN QUERY SELECT ('{ "MaxExceededError": ' || recordCount || ' }')::JSONB;
    END IF;
  ELSE
    RETURN QUERY SELECT ('{ "UnknownCommandError": ' || command || ' }')::JSONB;
  END IF;
END;
$$
LANGUAGE plpgsql;
ALTER FUNCTION pgdoc.store( INTEGER, TEXT, TEXT, JSONB, JSONB, INTEGER, JSONB ) OWNER TO pgdoc;
---
--- Store()tests
SELECT pgdoc.store( 0, 'pgdoc', 'pgdocTest', NULL, NULL, NULL, NULL ) AS data; 
SELECT pgdoc.store( 1, 'pgdoc', 'pgdocTest', '{ "runCommandTest": "store" }', NULL, NULL, NULL ) AS data; 
SELECT pgdoc.store( 2, 'pgdoc', 'pgdocTest', '{ "runCommandTest": "storeSearch" }', '{ "runCommandTest": "store" }', NULL, NULL ) AS data;
SELECT pgdoc.store( 3, 'pgdoc', 'pgdocTest', '{ "runCommandTest": "storeSearchMax" }', '{ "runCommandTest": "storeSearch" }', 1, NULL ) AS data;
SELECT pgdoc.store( 4, 'pgdoc', 'pgdocTest', '{ "runCommandTest": "storeSearchExclude" }', '{}', NULL, '{ "runCommandTest": "storeSearchMax" }' ) AS data;
SELECT pgdoc.store( 5, 'pgdoc', 'pgdocTest', '{ "runCommandTest": "storeSearchExcludeMax" }', '{}', 1, '{ "runCommandTest": "storeSearchExclude" }' ) AS data;
SELECT pgdoc.store( 5, 'pgdoc', 'pgdocTest', '{ "runCommandTest": "storeSearchExcludeMax" }', '{}', 0, '{ "runCommandTest": "storeSearchExclude" }' ) AS data;
--- Test utils
SELECT data FROM pgdoc.docs WHERE type = 'pgdocTest' AND data @> '{}';
DELETE FROM pgdoc.docs WHERE type = 'pgdocTest';


    -- recordCount :=
    --   WITH deleted AS
    --     (DELETE FROM docs WHERE type = docType AND data @> search)
    --     SELECT COUNT(*) FROM deleted;
    --   INSERT INTO docs VALUES ( docType , doc );
    -- RETURN recordCount;


CREATE OR REPLACE FUNCTION  pgdoc.retrieve( command INTEGER, schemaName TEXT, docType TEXT, doc JSONB, search JSONB, max INTEGER, exclude JSONB )
RETURNS SETOF JSONB AS
$$
DECLARE recordCount INTEGER;
DECLARE docs TEXT;
BEGIN
  docs := schemaName || '.docs' ;
  -- RAISE NOTICE 'recordCount: %', recordCount;
  IF command = 101 -- retrieve()
  THEN
    RETURN QUERY SELECT data FROM docs WHERE type = docType ;
  ELSIF command = 102 -- retrieve(), search
  THEN
    RAISE NOTICE 'search: %', search;
    RETURN QUERY SELECT data FROM docs WHERE type = docType AND data @> search ;
  ELSIF command = 103 -- retrieve(), search with maxMatch
  THEN
    recordCount := COUNT(*) FROM docs WHERE type = docType AND data @> search ;
    IF recordCount <= max
    THEN
      RETURN QUERY SELECT data FROM docs WHERE type = docType AND data @> search ;
    ELSE
      RETURN QUERY SELECT ('{ "MaxExceededError": ' || recordCount || ' }')::JSONB;
    END IF;
  ELSIF command = 104 -- retrieve(), search and exclude
  THEN
    RETURN QUERY SELECT data FROM docs WHERE type = docType AND data @> search AND NOT data @> exclude ;
  ELSIF command = 105 -- retrieve(), search and exclude with maxMatch
  THEN
    recordCount := COUNT(*) FROM docs WHERE type = docType AND data @> search AND NOT data @> exclude;
    IF recordCount <= max
    THEN
      RETURN QUERY SELECT data FROM docs WHERE type = docType AND data @> search AND NOT data @> exclude ;
    ELSE
      RETURN QUERY SELECT ('{ "MaxExceededError": ' || recordCount || ' }')::JSONB;
    END IF;
  ELSE
    RETURN QUERY SELECT ('{ "UnknownCommandError": ' || command || ' }')::JSONB;
  END IF;
END;
$$
LANGUAGE plpgsql;
ALTER FUNCTION pgdoc.retrieve( INTEGER, TEXT, TEXT, JSONB, JSONB, INTEGER, JSONB ) OWNER TO pgdoc;
---
--- Retrieve() tests
INSERT INTO docs VALUES ( 'pgdocTest' , '{ "id": -19, "group": "A", "x":1, "y":2, "complex": { "a": { "t": 7, "u": 3 } } }' );
INSERT INTO docs VALUES ( 'pgdocTest' , '{ "id": -20, "group": "B", "x":1, "y":2, "complex": { "a": { "t": 2, "u": 4 }, "c": 8 } }' );
INSERT INTO docs VALUES ( 'pgdocTest' , '{ "id": -21, "group": "B", "x":2, "y":1, "complex": { "a": { "t": 1, "u": -5 }, "b": 3 } }' );
INSERT INTO docs VALUES ( 'pgdocTest' , '{ "id": -22, "group": "A", "x":2, "y":1, "complex": { "a": { "t": 7, "u": 2 }, "b": 3 } }' );
SELECT pgdoc.retrieve( 100, 'pgdoc', 'pgdocTest', NULL, NULL, NULL, NULL ) AS data;
SELECT pgdoc.retrieve( 101, 'pgdoc', 'pgdocTest', NULL, NULL, NULL, NULL ) AS data;
SELECT pgdoc.retrieve( 102, 'pgdoc', 'pgdocTest', NULL, '{ "group": "A" }', NULL, NULL ) AS data;
SELECT pgdoc.retrieve( 103, 'pgdoc', 'pgdocTest', NULL, '{ "complex": { "a": { "t": 1, "u": -5 }, "b": 3 } }', 1, NULL ) AS data;
SELECT pgdoc.retrieve( 103, 'pgdoc', 'pgdocTest', NULL, '{ "complex": { "a": { "t": 1, "u": -5 }, "b": 3 } }', 0, NULL ) AS data;
SELECT pgdoc.retrieve( 102, 'pgdoc', 'pgdocTest', NULL, '{ "x": 2 }', NULL, '{ "group": "A" }' ) AS data;
SELECT pgdoc.retrieve( 104, 'pgdoc', 'pgdocTest', NULL, '{ "x": 2 }', NULL, '{ "group": "A" }' ) AS data;
SELECT pgdoc.retrieve( 105, 'pgdoc', 'pgdocTest', NULL, '{ "x": 1 }', 1, '{ "group": "B" }' ) AS data;
SELECT pgdoc.retrieve( 105, 'pgdoc', 'pgdocTest', NULL, '{ "x": 1 }', 0, '{ "group": "B" }' ) AS data;
--- Test utils
SELECT data FROM pgdoc.docs WHERE type = 'pgdocTest' AND data @> '{}';
DELETE FROM pgdoc.docs WHERE type = 'pgdocTest';




-- required for the above function to succeed
-- GRANT create,usage ON SCHEMA public TO pgdoc ;


-- TODO: all the rest
